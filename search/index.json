[{"content":"右值 右值以及与其相关的一系列特性是现代 C++ 中最重要的特性之一，最初的右值只有纯右值一种，之后为了高效移动资源的需求，C++11 将将亡值以及移动语义作为新特性加入到了标准中。结合类型推导形成完美转发机制使得 C++的资源管理从未如此高效。\n纯右值 在 C++ 98 中，表达式的值类别只有左值和右值两种，左值可以认为是在代码中有标识符的变量，或者说是可以取得内存地址的变量。而右值也就是纯右值，即不能直接取得其在内存中的地址的值，如单纯的数字 1 ，只能作为临时的变量。还有一种分辨方法是，能够在表达式中位于等号左边的值为左值，而右值只能位于等号的右侧，即不能赋值，这也与其没有对应内存地址而对应。\n1 2 3 int x = 1; // x是左值，1是右值 int *y = \u0026amp;x; // y也是左值 int *z = \u0026amp;1; // 错误，1是右值无法取地址 将亡值与移动语义 对将亡值的需求开始于 C++ 98 时开发者希望有一种方法快速进行资源管理类的资源交换或传递资源。比如一个类的成员变量中包括一个指针，则如果只有拷贝构造或者拷贝赋值时，会进行指针的浅拷贝，那么就会造成两个指针指向同一块内存资源的情况，如果此类的析构函数负责对指针进行释放，那么这两个实例在先后析构的过程中会调用两次析构函数，造成内存的多次释放。而如果使用深拷贝，即新开辟一段内存再对所有指针指向的元素进行复制，显然不够高效，且拷贝操作的形参带有 const 属性，也无法对原对象进行操作。\n因此，大佬们为了解决这一问题，做出新的约定，使用\u0026amp;\u0026amp;表示一种特殊的引用，当匹配到这样的实参时，构造或赋值函数会对所引用的实例做特殊处理，如在复制指针后将其指针指向 null，这样只需在析构时进行特殊判断即可。\n1 2 3 4 5 6 7 8 9 10 class field { public: field(const field \u0026amp;other) { ptr = other.ptr; } //拷贝构造，析构时会造成内存的多次释放 field(field \u0026amp;\u0026amp;other) { // 以\u0026amp;\u0026amp;匹配时，会对other进行处理，避免多次释放 ptr = other.ptr; other.ptr = nullptr; } private: float *ptr; }; 在 C++ 11 后，这一特性作为移动语义进入了新标准，而\u0026amp;\u0026amp;所表示的引用则被称为右值引用，顾名思义，右值引用可以匹配到右值上：\n1 2 3 4 void func(int \u0026amp;\u0026amp;i) { std::cout \u0026lt;\u0026lt; \u0026#34;右值\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func(const int \u0026amp;i) { std::cout \u0026lt;\u0026lt; \u0026#34;左值\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { func(1); } // 输出\u0026#34;右值\u0026#34; 虽然右值 1 也能匹配到从 const int\u0026amp; 上，但显然此时右值引用 int\u0026amp;\u0026amp; 的匹配优先度较高。因为上面所提到的移动构造或移动语义的需求，显然需要一种方法将左值匹配到右值引用上，这一方式就是 std:: move，std:: move 的唯一作用其实就是在左值前强制加上\u0026amp;\u0026amp;，使其变为一种特殊的右值，即将亡值。\n将亡值 将亡值是介于纯右值和左值之间的一种值类别，首先其不能出现在表达式左侧，在代码中没有明确的标识符，这体现了它偏右值的性质；但它事实上存在于内存中，具有内存地址，这是它偏向于左值的一面。将亡值通常表示它会在不久之后便被销毁，如隐式转换便会产生将亡值，而人为使用std::move来使用将亡值主要发生在使用移动语义时。 将亡值可以匹配到右值引用上，使得移动语义中的右值引用形参可以变相的接受左值，以此实现高效且安全的资源管理。值得注意的是，右值引用其实是一种左值，这一点可以用如下代码验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void func(int \u0026amp;\u0026amp;i) { std::cout \u0026lt;\u0026lt; \u0026#34;右值\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func(const int \u0026amp;i) { std::cout \u0026lt;\u0026lt; \u0026#34;左值\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } int main() { int i = 1; int \u0026amp;\u0026amp;m = std::move(i); func(std::move(i)); func(m); } /* 右值 左值 */ 第一个 func 是标准的右值引用调用，它通过 move 将 i 变为将亡值，而第二个 func 属于直接传入右值引用，结果显示其匹配到了左值版本上。分析可知，std:: move (i) 产生的将亡值直接作为实参时，由于将亡值属于右值，故匹配右值版本的函数；但当其已经被赋值给右值引用后，右值引用虽然引用了一个右值但本身有明确的标识符，显然属于左值，因此匹配到左值版本的函数上。\n完美转发 提到移动语义就不得不提完美转发，完美转发的需求来源于在需要将函数形参在函数内作为另一个函数的实参转发过去时，即进行函数的转发时，由于在函数内即使是以右值引用传入的参数也已经有了标识符和地址，属于左值，故在函数内部丢失了其传入函数时的值类别。而很多时候我们希望在函数内部保留其传入时的值类别以保证转发过程的高效 (通常是要调动移动语义来避免拷贝)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; template \u0026lt;typename T\u0026gt; void print(T\u0026amp; t) { std::cout \u0026lt;\u0026lt; \u0026#34;Lvalue ref\u0026#34; \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename T\u0026gt; void print(T\u0026amp;\u0026amp; t) { std::cout \u0026lt;\u0026lt; \u0026#34;Rvalue ref\u0026#34; \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename T\u0026gt; void testForward(T\u0026amp;\u0026amp; v) { print(v); // v此时已经是个左值了,永远调用左值版本的print print(std::forward\u0026lt;T\u0026gt;(v)); //本文的重点 print(std::move(v)); //永远调用右值版本的print std::cout \u0026lt;\u0026lt; \u0026#34;======================\u0026#34; \u0026lt;\u0026lt; std::endl; } int main(int argc, char* argv[]) { int x = 1; testForward(x); //实参为左值 testForward(std::move(x)); //实参为右值 } 在上面的例子中，变量 v 在函数内部永远是左值，无论它传入函数时是左值还是右值，以此当在函数内调用 print (v) 时，永远使用左值版本，而如果用 std:: move 则永远只能调用右值版本。在很多时候，比如在函数内需要调用类的构造函数时，我们希望以左值传入的 v 能在函数内调用拷贝构造，而右值版本的调用移动构造，即保留其左右值的性质。问题在于，在函数内部似乎难以知晓参数传入前的值类别。\n事实显然并非如此，注意上面的代码中 testForward 是一个模板参数，且使用了万能引用，根据[[B-Study/C++/类型推导|类型推导]]的规则，万能引用模板在接受左值时模板参数 T 会推导为引用类型，之后发生引用折叠使最终形参为 T\u0026amp;；而对于右值参数 T 会直接推导为不带引用的类型。显然，模板参数 T 为我们提供了在函数内部了解实参传入时是左值还是右值的方法。由此 C++ 提供了 std:: forward\u0026lt;T\u0026gt; 来在函数内部恢复实参的值类别。一种 std:: forward 的实现方法如下：\n1 2 3 4 template\u0026lt;typename _Tp\u0026gt; constexpr _Tp\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp; __t) noexcept { return static_cast\u0026lt;_Tp\u0026amp;\u0026amp;\u0026gt;(__t); } 当传入 testForward 的参数是左值是，_Tp是T\u0026amp;，上面的代码保证不论 T 被推到为 T\u0026amp;还是 T，其形参都是左值引用，符合 testForward 内 v 始终为左值的规律；而对于模板参数被推导为左值引用的情况，以 int 类型为例，上面的代码变为：\n1 2 3 constexpr int \u0026amp; //引用折叠 forward(int \u0026amp; __t) noexcept { return static_cast\u0026lt;int \u0026amp;\u0026gt;(__t); } //引用折叠 发生引用折叠后最终返回值为左值引用。而对于模板参数被推导为不带引用的类型，即输入 testForward 的是右值引用的情况，forward 变为：\n1 2 3 constexpr int \u0026amp;\u0026amp; forward(int \u0026amp; __t) noexcept { return static_cast\u0026lt;int \u0026amp;\u0026amp;\u0026gt;(__t); } 最终代码将左值引用转换为右值。\n注意 注意到static_cast\u0026lt;int \u0026amp;\u0026amp;\u0026gt;(__t) 返回的应当是一个将亡值，类似于std::move()的返回结果，因此可以匹配到右值引用为形参的移动语义上，而非像上面的例子中的右值引用一样调用左值引用版本的函数。 完美转发使得移动语义的使用范围大大提升，标准库的许多容器为了效率都基于完美转发，对于拷贝消耗远大于移动的情况，完美转发+移动语义是一种高效且安全的处理方法。\n","date":"2025-03-16T23:55:11+08:00","permalink":"https://localhost:1313/p/%E5%8F%B3%E5%80%BC%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","title":"右值、移动语义、完美转发"},{"content":"引子 在学习 AMReX 的时候，注意到在他们给出的示例代码中按值捕获的 lambda 闭包可以在闭包内修改数组的值，显然其按值传入的过程中应当发生了指针的拷贝，但当使用 AI 复现时出现错误，最终发现在不使用 mutable 关键字时，lambda 内只会调用变量的 const 版本成员函数，而 AI 给出的 Array 4 的 const 成员函数返回 const reference，故无法进行赋值和修改。由此引出下面的关于 lambda 和 const 成员函数的思考探究。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 for (amrex::MFIter mfi(phi_old); mfi.isValid(); ++mfi) { const amrex::Box\u0026amp; bx = mfi.validbox(); const amrex::Array4\u0026lt;amrex::Real\u0026gt;\u0026amp; phiOld = phi_old.array(mfi); const amrex::Array4\u0026lt;amrex::Real\u0026gt;\u0026amp; phiNew = phi_new.array(mfi); // advance the data by dt amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) { // ********************************** // EVOLVE VALUES FOR EACH CELL // ********************************** phiNew(i, j, k) = phiOld(i, j, k) + dt * ((phiOld(i + 1, j, k) - 2. * phiOld(i, j, k) + phiOld(i - 1, j, k)) / (dx[0] * dx[0]) + (phiOld(i, j + 1, k) - 2. * phiOld(i, j, k) + phiOld(i, j - 1, k)) / (dx[1] * dx[1]) + (phiOld(i, j, k + 1) - 2. * phiOld(i, j, k) + phiOld(i, j, k - 1)) / (dx[2] * dx[2])); }); } 探究 在使用 lambda 闭包时，编译器会创建一个结构体并重载其 operator () 来实现指定的函数，按值捕获的变量会被直接拷贝进结构体内作为成员变量，按引用捕获的变量则会以引用的形式储存为成员变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; class Test { public: void nonConstFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;nonConstFunc called\\n\u0026#34;; } void constFunc() const { std::cout \u0026lt;\u0026lt; \u0026#34;constFunc called\\n\u0026#34;; } }; int main() { Test t; auto lambda = [=]() { // t.nonConstFunc();//❌ 错误`operator()`是`const`t 在 `operator()`内是`const` t.constFunc(); // ✅ 允许 }; lambda(); } 在 cpp insight 中上述代码的结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; class Test { public: inline void nonConstFunc() { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;nonConstFunc called\\n\u0026#34;); } inline void constFunc() const { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;constFunc called\\n\u0026#34;); } // inline constexpr Test() noexcept = default; // inline constexpr Test(const Test \u0026amp;) noexcept = default; }; int main() { Test t; class __lambda_12_19 { public: inline /*constexpr */ void operator()() const { t.constFunc(); } private: Test t; public: __lambda_12_19(const Test \u0026amp; _t) : t{_t} {} }; __lambda_12_19 lambda = __lambda_12_19{t}; lambda.operator()(); return 0; } 注意到重载的 operator 函数为 const 成员函数，此时函数体内的成员变量 t 被视为 const Test 类型，只能调用其对应的 const 成员函数，如果使用 t.nonConstFunc () 则编译错误。\n当按引用捕获时，cpp insight 给出结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; class Test { public: void nonConstFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;nonConstFunc called\\n\u0026#34;; } void constFunc() const { std::cout \u0026lt;\u0026lt; \u0026#34;constFunc called\\n\u0026#34;; } }; int main() { Test t; auto lambda = [\u0026amp;]() { t.nonConstFunc(); t.constFunc(); }; lambda(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; class Test { public: inline void nonConstFunc() { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;nonConstFunc called\\n\u0026#34;); } inline void constFunc() const { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;constFunc called\\n\u0026#34;); } // inline constexpr Test() noexcept = default; }; int main() { Test t; class __lambda_12_19 { public: inline /*constexpr */ void operator()() const { t.nonConstFunc(); t.constFunc(); } private: Test \u0026amp; t; public: __lambda_12_19(Test \u0026amp; _t) : t{_t} {} }; __lambda_12_19 lambda = __lambda_12_19{t}; lambda.operator()(); return 0; } 没有出现编译错误，尽管在 operator () const 内调用了 t 的非 const 成员函数。\n在不使用 lambda 表达式的条件下举例，考虑有如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B b; public: void func() const { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { A a; a.func(); const A a2; a2.func(); return 0; } /* non-const B::modify() called non-const version const B::modify() called const version */ 结果显而易见，const A 调用 cont 成员函数，且 const 成员函数内的 b 也被视为 const，反之全部调用非 const 的成员函数。如果像 lambda 闭包一样只保留 A 的 const 成员函数，则全部调用 const 成员函数，因为非 const 类型的 A 的 this 指针同样可以代入 const 成员函数的形参，不会产生 const 的丢失，编译器不会阻止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B b; public: void func() const { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // void func() { // b.modify(); // std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // } }; int main() { A a; a.func(); const A a2; a2.func(); return 0; } /* const B::modify() called const version const B::modify() called const version */ 但是如果此时去掉 B 类型的 const 成员函数，则编译器会报错，显示在 func () const 内 b 被当作 const B，因此无法带入到非 const 的 modify () 函数中，因为会造成 const 的丢失，无论 A 本身是否是 const 类型：\n1 2 3 main.cpp:15:5: error: \u0026#39;this\u0026#39; argument to member function \u0026#39;modify\u0026#39; has type \u0026#39;const B\u0026#39;, but function is not marked const 15 | b.modify(); | ^ 这与在 lambda 闭包中的行为一致。\n当模拟通过引用捕获外部变量时，可以使用如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B\u0026amp; b; public: A(B\u0026amp; b) : b(b){}; void func() const { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a(b); a.func(); const A a2(b); a2.func(); return 0; } /* non-const B::modify() called non-const version non-const B::modify() called const version */ 输出结果与按值捕获时不同，尽管提供了 const 和非 const 两个版本，最终 b 所调用的都是非 const 版本，这说明编译器并不会在 const 成员函数内限制引用类型的非 const 成员变量为 const，为了验证可以用 decltype 推导一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B\u0026amp; b; public: A(B\u0026amp; b) : b(b){}; void func() const { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a(b); a.func(); const A a2(b); a2.func(); return 0; } /* non-const B::modify() called B \u0026amp; non-const version non-const B::modify() called B \u0026amp; const version */ 对于按值而非引用储存的成员变量，会有不同的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B b; public: // A(B\u0026amp; b) : b(b){}; void func() const { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a; a.func(); const A a2; a2.func(); return 0; } /* non-const B::modify() called B \u0026amp; non-const version const B::modify() called B const \u0026amp; const version */ 不清楚编译器在这里做了什么处理，当使用 decltype (b) 时结果均为 B，而使用 decltype ((b)) 时结果显示 const 成员函数中的结果带上了 const 关键字。\n对于使用指针的情况，const 成员函数同样会使其变为指针常量，即不能更换其所指向的地址，但这并不代表此指针指向的是常量，因此可以且会优先匹配非 const 成员函数，最终效果介于引用和非引用之间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B* b; public: A(B* b) : b(b){}; void func() const { b-\u0026gt;modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b-\u0026gt;modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a(\u0026amp;b); a.func(); const A a2(\u0026amp;b); a2.func(); return 0; } /* non-const B::modify() called B* \u0026amp; non-const version non-const B::modify() called B* const \u0026amp; const version */ 结论 lambda 闭包重载的 operator () 函数带有 const 关键字，如果按值捕获则只会调用成员变量的带 const 的成员函数。 const 成员函数会使得其中的非引用成员变量被视为 const，从而只能调用其对应的 const 成员函数。 对于指针作为成员变量的情况，在const 成员函数内会变为指针常量，但这并不妨碍其优先调用非 const 的成员变量，因为指针所指向的对象并非 const。 ","date":"2025-03-16T14:49:53+08:00","permalink":"https://localhost:1313/p/lambda%E9%97%AD%E5%8C%85%E4%B8%8Econst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","title":"Lambda闭包与const成员函数"},{"content":"类型推导 类型推导主要会发生在以下几种情况：\n模板类型推导 auto 推导 decltype 模板推导 最常见的类型推导是模板中的类型推导，可以根据函数模板的形参的具体形式分为以下三种情况：\n形参为引用或指针，但不是通用引用 形参为通用引用 形参不是任何引用或指针 以上三种情况在进行类型推导时，编译器会按照不同的规则进行，尽管在大多数情况下推导的结果符合直觉而无需套用规则。\n形参为引用或指针，但不是通用引用 在情况下，如果输入的实参是一个引用，则将引用去掉后进行匹配，如果实参并非引用则直接进行匹配。举例说明：\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { int a = 1l; int \u0026amp;b = a; func(a); func(b); } 对应的推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int \u0026amp; param) { } #endif int main() { int a = 1; int \u0026amp; b = a; func(a); func(b); return 0; } 可以看到，对于 int 和 int\u0026amp; 两种类型，最终的推导结果是相同的，也就是说 int\u0026amp; 在进行推导时相当于去掉了\u0026amp;以 int 进行推导，推导结果得到 T 为 int。如果考虑更复杂的情况，即实参是一个指针，则按照规则直接进行匹配，将模板参数 T 推导为 int*，最终得到的形参是 int*\u0026amp;。\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { int a = 1; int *c = \u0026amp;a; func(c); } 对应的推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int *\u0026gt;(int *\u0026amp; param) { } #endif int main() { int a = 1L; int * c = \u0026amp;a; func(c); return 0; } 在上面的例子中，去掉引用后的匹配实际上相当于直接使得 T 等于所出入的类型，但当传入参数或者模板形参中任意一者含有 const 时，const 关键字会被保留，区别在于 const 是否属于模板参数 T 的一部分。\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); } 推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;const int\u0026gt;(const int \u0026amp; param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); return 0; } 此时由于函数模板的形参中没有 const，const 关键字被推导为 T 的一部分。\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(const T\u0026amp; param) {} int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(const T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(const int \u0026amp; param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); return 0; } 此时 const 关键字不再是 T 的一部分。\n而对于输入的实参为右值的情况，推导规则与左值相同，但只有在推导得出的形参中含有 const 关键字 (模板或实参带有 const 均可) 时才能通过编译。这是因为只有 const 类型的左值引用可以绑定到右值。\n1 2 3 4 5 6 7 8 9 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(const T \u0026amp;param) { } int main() { int a = 1; func(std::move(a)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(const T \u0026amp; param) { } /* First instantiated from: insights.cpp:8 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(const int \u0026amp; param) { } #endif int main() { int a = 1; func(static_cast\u0026lt;const int \u0026amp;\u0026amp;\u0026gt;(std::move(a))); return 0; } 形参为通用引用 当形参为 T\u0026amp;\u0026amp; 所示的右值引用时，按照如下规则进行推导：\n如果实参为左值，模板参数 T 被推导为左值引用，同时形参发生引用折叠，即 T\u0026amp; \u0026amp;\u0026amp;折叠为 T\u0026amp;，最终形参为左值引用。 如果实参是右值，则直接进行匹配。 1 2 3 4 5 6 7 8 9 10 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(T\u0026amp;\u0026amp; param) { } int main() { int a = 1; func(a); func(std::move(a)); } 上面代码的对应结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(T \u0026amp;\u0026amp; param) { } /* First instantiated from: insights.cpp:8 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int \u0026amp;\u0026gt;(int \u0026amp; param) { } #endif /* First instantiated from: insights.cpp:9 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int \u0026amp;\u0026amp; param) { } #endif int main() { int a = 1; func(a); func(std::move(a)); func(1); return 0; } 注意如果模板形参为 const T\u0026amp;\u0026amp;，这并非通用引用，无法触发引用折叠，此模板只能接受右值。\n形参并非任何指针或引用 在这种情况下，由于形参并非引用或指针，实参所带有的引用或 const 声明在函数内不会生效，只会被用来创建函数内的临时变量，因此推导规则为：\n如果实参为引用，则忽略引用 如果忽略引用后带有 const 或 volatile 关键字，则通用忽略他们。 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(T param) { } int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); func(1); func(std::move(a)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(T param) { } /* First instantiated from: insights.cpp:9 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); func(1); func(std::move(a)); return 0; } 可以看到无论是输入左值还是右值，最终推导结果是一样的。\nauto 当使用 auto 声明变量时，同样会发生类型推导，而且此时类型推导的规则与上述模板中的类型推导规则基本相同。可以将 auto 本身看作模板参数 T，如果声明为 const auto 则模板函数形参为 const T，以此类推。只有当 auto 声明后出现花括号时，其行为会与模板推导有所不同，auto 会将花括号内的内容推导为初始化列表 std:: initializer_list\u0026lt;T\u0026gt;，而模板函数无法识别花括号输入。\ndecltype 推导规则 decltype 的作用是返回表达式的类型，因此也需要进行类型推导，但其规则比较特殊，按照输入表达式类型的不同，其返回值也不同：\n如果输入不带有括号的标识符或类访问表达式，则直接返回其类型，包括 const 关键字或引用和指针类型。 如果输入的是其他类型为 T 的表达式，则： 如果表达式的值类别为左值，返回 T\u0026amp; 如果表达式的值类别为纯右值，返回 T 如果表达式的值类别为将亡值，返回 T\u0026amp;\u0026amp; note 标识符值为用户自定义的用来表示变量、函数名、类名等自定义模块的名称；变量名、类名、函数名等都属于标识符。 类访问表达式即形如className.member的表达式。 C++中任何表达式都有两个基本属性，即值类别和类型，类型即int, float, double，int*, const double等，值类别指左值、纯右值或将亡值。 举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; int\u0026amp; func1() {} int func2() {} struct X { int* x; const double y = 0; }; int main() { int i = 1; int j = 2; const int\u0026amp; k = i; X stru; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(std::as_const(i))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i + j)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i += j)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(std::move(i))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(func1())\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(func2())\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(stru.x)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((stru.x))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((stru.y))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* 输出： int int const \u0026amp; int int \u0026amp; int \u0026amp;\u0026amp; int \u0026amp; int int * int *\u0026amp; double const \u0026amp; */ 第一种情况直接返回 i 的类型 int，第二中情况属于函数调用，函数返回值为 const int\u0026amp; 为左值，按照规则二结果为 const int \u0026amp;；之后两个加法表达式分别返回右值和左值，按照规则二分别返回 int 和 int \u0026amp;；std:: move () 返回将亡值，因此结果为 int\u0026amp;\u0026amp;，接下来两个函数调用分别返回左值和右值同样按照规则二推导；最后三个中第一个属于类访问表达式，按照规则一直接返回成员变量的类型，第二个在类访问表达式外加上了括号，属于规则二，返回 int* \u0026amp;，同理最后一个返回 const double \u0026amp;。\ndecltype (auto) 一种特殊用法是将 decltype 与 auto 连用，它表示需要进行 auto 推导，但以 decltype 的规则进行：\n1 2 3 4 Widget w; const Widget\u0026amp; cw = w; auto myWidget1 = cw; //按照auto规则myWidget1推导为Widget decltype(auto) myWidget2 = cw; // myWidget2类型为const Widget \u0026amp; 一个常见的用法是在 lambda 表达式或模板函数中自动推导返回值，如果只使用 auto，则返回值的引用类型会在推导过程中被忽略，最终导致返回了一个右值而不是左值引用。使用 decltype (auto) 进行推导则会直接给出返回值的类型，可以配合 std::forward\u0026lt;T\u0026gt; 实现完美转发。\n","date":"2025-03-08T11:26:28+08:00","permalink":"https://localhost:1313/p/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/","title":"类型推导"}]