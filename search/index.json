[{"content":"类型推导 类型推导主要会发生在以下几种情况：\n模板类型推导 auto 推导 decltype 模板推导 最常见的类型推导是模板中的类型推导，可以根据函数模板的形参的具体形式分为以下三种情况：\n形参为引用或指针，但不是通用引用 形参为通用引用 形参不是任何引用或指针 以上三种情况在进行类型推导时，编译器会按照不同的规则进行，尽管在大多数情况下推导的结果符合直觉而无需套用规则。\n形参为引用或指针，但不是通用引用 在情况下，如果输入的实参是一个引用，则将引用去掉后进行匹配，如果实参并非引用则直接进行匹配。举例说明：\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { int a = 1l; int \u0026amp;b = a; func(a); func(b); } 对应的推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int \u0026amp; param) { } #endif int main() { int a = 1; int \u0026amp; b = a; func(a); func(b); return 0; } 可以看到，对于 int 和 int\u0026amp; 两种类型，最终的推导结果是相同的，也就是说 int\u0026amp; 在进行推导时相当于去掉了\u0026amp;以 int 进行推导，推导结果得到 T 为 int。如果考虑更复杂的情况，即实参是一个指针，则按照规则直接进行匹配，将模板参数 T 推导为 int*，最终得到的形参是 int*\u0026amp;。\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { int a = 1; int *c = \u0026amp;a; func(c); } 对应的推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int *\u0026gt;(int *\u0026amp; param) { } #endif int main() { int a = 1L; int * c = \u0026amp;a; func(c); return 0; } 在上面的例子中，去掉引用后的匹配实际上相当于直接使得 T 等于所出入的类型，但当传入参数或者模板形参中任意一者含有 const 时，const 关键字会被保留，区别在于 const 是否属于模板参数 T 的一部分。\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); } 推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;const int\u0026gt;(const int \u0026amp; param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); return 0; } 此时由于函数模板的形参中没有 const，const 关键字被推导为 T 的一部分。\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(const T\u0026amp; param) {} int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(const T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(const int \u0026amp; param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); return 0; } 此时 const 关键字不再是 T 的一部分。\n而对于输入的实参为右值的情况，推导规则与左值相同，但只有在推导得出的形参中含有 const 关键字 (模板或实参带有 const 均可) 时才能通过编译。这是因为只有 const 类型的左值引用可以绑定到右值。\n1 2 3 4 5 6 7 8 9 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(const T \u0026amp;param) { } int main() { int a = 1; func(std::move(a)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(const T \u0026amp; param) { } /* First instantiated from: insights.cpp:8 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(const int \u0026amp; param) { } #endif int main() { int a = 1; func(static_cast\u0026lt;const int \u0026amp;\u0026amp;\u0026gt;(std::move(a))); return 0; } 注意 此处并不涉及移动操作，因为触发移动操作的要求是右值引用必须被绑定到对应的T\u0026amp;\u0026amp;形式的形参上。 形参为通用引用 当形参为 T\u0026amp;\u0026amp; 所示的右值引用时，按照如下规则进行推导：\n如果实参为左值，模板参数 T 被推导为左值引用，同时形参发生引用折叠，即 T\u0026amp; \u0026amp;\u0026amp;折叠为 T\u0026amp;，最终形参为左值引用。 如果实参是右值，则直接进行匹配。 1 2 3 4 5 6 7 8 9 10 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(T\u0026amp;\u0026amp; param) { } int main() { int a = 1; func(a); func(std::move(a)); } 上面代码的对应结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(T \u0026amp;\u0026amp; param) { } /* First instantiated from: insights.cpp:8 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int \u0026amp;\u0026gt;(int \u0026amp; param) { } #endif /* First instantiated from: insights.cpp:9 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int \u0026amp;\u0026amp; param) { } #endif int main() { int a = 1; func(a); func(std::move(a)); func(1); return 0; } 注意如果模板形参为 const T\u0026amp;\u0026amp;，这并非通用引用，无法触发引用折叠，此模板只能接受右值。\n形参并非任何指针或引用 在这种情况下，由于形参并非引用或指针，实参所带有的引用或 const 声明在函数内不会生效，只会被用来创建函数内的临时变量，因此推导规则为：\n如果实参为引用，则忽略引用 如果忽略引用后带有 const 或 volatile 关键字，则通用忽略他们。 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(T param) { } int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); func(1); func(std::move(a)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(T param) { } /* First instantiated from: insights.cpp:9 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); func(1); func(std::move(a)); return 0; } 可以看到无论是输入左值还是右值，最终推导结果是一样的。\nauto 当使用 auto 声明变量时，同样会发生类型推导，而且此时类型推导的规则与上述模板中的类型推导规则基本相同。可以将 auto 本身看作模板参数 T，如果声明为 const auto 则模板函数形参为 const T，以此类推。只有当 auto 声明后出现花括号时，其行为会与模板推导有所不同，auto 会将花括号内的内容推导为初始化列表 std:: initializer_list\u0026lt;T\u0026gt;，而模板函数无法识别花括号输入。\ndecltype 推导规则 decltype 的作用是返回表达式的类型，因此也需要进行类型推导，但其规则比较特殊，按照输入表达式类型的不同，其返回值也不同：\n如果输入不带有括号的标识符或类访问表达式，则直接返回其类型，包括 const 关键字或引用和指针类型。 如果输入的是其他类型为 T 的表达式，则： 如果表达式的值类别为左值，返回 T\u0026amp; 如果表达式的值类别为纯右值，返回 T 如果表达式的值类别为将亡值，返回 T\u0026amp;\u0026amp; note 标识符值为用户自定义的用来表示变量、函数名、类名等自定义模块的名称；变量名、类名、函数名等都属于标识符。 类访问表达式即形如className.member的表达式。 C++中任何表达式都有两个基本属性，即值类别和类型，类型即int, float, double，int*, const double等，值类别指左值、纯右值或将亡值。 举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; int\u0026amp; func1() {} int func2() {} struct X { int* x; const double y = 0; }; int main() { int i = 1; int j = 2; const int\u0026amp; k = i; X stru; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(std::as_const(i))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i + j)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i += j)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(std::move(i))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(func1())\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(func2())\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(stru.x)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((stru.x))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((stru.y))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* 输出： int int const \u0026amp; int int \u0026amp; int \u0026amp;\u0026amp; int \u0026amp; int int * int *\u0026amp; double const \u0026amp; */ 第一种情况直接返回 i 的类型 int，第二中情况属于函数调用，函数返回值为 const int\u0026amp; 为左值，按照规则二结果为 const int \u0026amp;；之后两个加法表达式分别返回右值和左值，按照规则二分别返回 int 和 int \u0026amp;；std:: move () 返回将亡值，因此结果为 int\u0026amp;\u0026amp;，接下来两个函数调用分别返回左值和右值同样按照规则二推导；最后三个中第一个属于类访问表达式，按照规则一直接返回成员变量的类型，第二个在类访问表达式外加上了括号，属于规则二，返回 int* \u0026amp;，同理最后一个返回 const double \u0026amp;。\ndecltype (auto) 一种特殊用法是将 decltype 与 auto 连用，它表示需要进行 auto 推导，但以 decltype 的规则进行：\n1 2 3 4 Widget w; const Widget\u0026amp; cw = w; auto myWidget1 = cw; //按照auto规则myWidget1推导为Widget decltype(auto) myWidget2 = cw; // myWidget2类型为const Widget \u0026amp; 一个常见的用法是在 lambda 表达式或模板函数中自动推导返回值，如果只使用 auto，则返回值的引用类型会在推导过程中被忽略，最终导致返回了一个右值而不是左值引用。使用 decltype (auto) 进行推导则会直接给出返回值的类型，可以配合 std::forward\u0026lt;T\u0026gt; 实现完美转发。\n","date":"2025-03-08T11:26:28+08:00","permalink":"https://localhost:1313/p/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/","title":"类型推导"}]