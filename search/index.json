[{"content":"引子 在学习 AMReX 的时候，注意到在他们给出的示例代码中按值捕获的 lambda 闭包可以在闭包内修改数组的值，显然其按值传入的过程中应当发生了指针的拷贝，但当使用 AI 复现时出现错误，最终发现在不使用 mutable 关键字时，lambda 内只会调用变量的 const 版本成员函数，而 AI 给出的 Array 4 的 const 成员函数返回 const reference，故无法进行赋值和修改。由此引出下面的关于 lambda 和 const 成员函数的思考探究。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 for (amrex::MFIter mfi(phi_old); mfi.isValid(); ++mfi) { const amrex::Box\u0026amp; bx = mfi.validbox(); const amrex::Array4\u0026lt;amrex::Real\u0026gt;\u0026amp; phiOld = phi_old.array(mfi); const amrex::Array4\u0026lt;amrex::Real\u0026gt;\u0026amp; phiNew = phi_new.array(mfi); // advance the data by dt amrex::ParallelFor(bx, [=] AMREX_GPU_DEVICE(int i, int j, int k) { // ********************************** // EVOLVE VALUES FOR EACH CELL // ********************************** phiNew(i, j, k) = phiOld(i, j, k) + dt * ((phiOld(i + 1, j, k) - 2. * phiOld(i, j, k) + phiOld(i - 1, j, k)) / (dx[0] * dx[0]) + (phiOld(i, j + 1, k) - 2. * phiOld(i, j, k) + phiOld(i, j - 1, k)) / (dx[1] * dx[1]) + (phiOld(i, j, k + 1) - 2. * phiOld(i, j, k) + phiOld(i, j, k - 1)) / (dx[2] * dx[2])); }); } 探究 在使用 lambda 闭包时，编译器会创建一个结构体并重载其 operator () 来实现指定的函数，按值捕获的变量会被直接拷贝进结构体内作为成员变量，按引用捕获的变量则会以引用的形式储存为成员变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; class Test { public: void nonConstFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;nonConstFunc called\\n\u0026#34;; } void constFunc() const { std::cout \u0026lt;\u0026lt; \u0026#34;constFunc called\\n\u0026#34;; } }; int main() { Test t; auto lambda = [=]() { // t.nonConstFunc();//❌ 错误`operator()`是`const`t 在 `operator()`内是`const` t.constFunc(); // ✅ 允许 }; lambda(); } 在 cpp insight 中上述代码的结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; class Test { public: inline void nonConstFunc() { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;nonConstFunc called\\n\u0026#34;); } inline void constFunc() const { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;constFunc called\\n\u0026#34;); } // inline constexpr Test() noexcept = default; // inline constexpr Test(const Test \u0026amp;) noexcept = default; }; int main() { Test t; class __lambda_12_19 { public: inline /*constexpr */ void operator()() const { t.constFunc(); } private: Test t; public: __lambda_12_19(const Test \u0026amp; _t) : t{_t} {} }; __lambda_12_19 lambda = __lambda_12_19{t}; lambda.operator()(); return 0; } 注意到重载的 operator 函数为 const 成员函数，此时函数体内的成员变量 t 被视为 const Test 类型，只能调用其对应的 const 成员函数，如果使用 t.nonConstFunc () 则编译错误。\n当按引用捕获时，cpp insight 给出结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; class Test { public: void nonConstFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;nonConstFunc called\\n\u0026#34;; } void constFunc() const { std::cout \u0026lt;\u0026lt; \u0026#34;constFunc called\\n\u0026#34;; } }; int main() { Test t; auto lambda = [\u0026amp;]() { t.nonConstFunc(); t.constFunc(); }; lambda(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;iostream\u0026gt; class Test { public: inline void nonConstFunc() { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;nonConstFunc called\\n\u0026#34;); } inline void constFunc() const { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;constFunc called\\n\u0026#34;); } // inline constexpr Test() noexcept = default; }; int main() { Test t; class __lambda_12_19 { public: inline /*constexpr */ void operator()() const { t.nonConstFunc(); t.constFunc(); } private: Test \u0026amp; t; public: __lambda_12_19(Test \u0026amp; _t) : t{_t} {} }; __lambda_12_19 lambda = __lambda_12_19{t}; lambda.operator()(); return 0; } 没有出现编译错误，尽管在 operator () const 内调用了 t 的非 const 成员函数。\n在不使用 lambda 表达式的条件下举例，考虑有如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B b; public: void func() const { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { A a; a.func(); const A a2; a2.func(); return 0; } /* non-const B::modify() called non-const version const B::modify() called const version */ 结果显而易见，const A 调用 cont 成员函数，且 const 成员函数内的 b 也被视为 const，反之全部调用非 const 的成员函数。如果像 lambda 闭包一样只保留 A 的 const 成员函数，则全部调用 const 成员函数，因为非 const 类型的 A 的 this 指针同样可以代入 const 成员函数的形参，不会产生 const 的丢失，编译器不会阻止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B b; public: void func() const { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } // void func() { // b.modify(); // std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // } }; int main() { A a; a.func(); const A a2; a2.func(); return 0; } /* const B::modify() called const version const B::modify() called const version */ 但是如果此时去掉 B 类型的 const 成员函数，则编译器会报错，显示在 func () const 内 b 被当作 const B，因此无法带入到非 const 的 modify () 函数中，因为会造成 const 的丢失，无论 A 本身是否是 const 类型：\n1 2 3 main.cpp:15:5: error: \u0026#39;this\u0026#39; argument to member function \u0026#39;modify\u0026#39; has type \u0026#39;const B\u0026#39;, but function is not marked const 15 | b.modify(); | ^ 这与在 lambda 闭包中的行为一致。\n当模拟通过引用捕获外部变量时，可以使用如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;iostream\u0026gt; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B\u0026amp; b; public: A(B\u0026amp; b) : b(b){}; void func() const { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a(b); a.func(); const A a2(b); a2.func(); return 0; } /* non-const B::modify() called non-const version non-const B::modify() called const version */ 输出结果与按值捕获时不同，尽管提供了 const 和非 const 两个版本，最终 b 所调用的都是非 const 版本，这说明编译器并不会在 const 成员函数内限制引用类型的非 const 成员变量为 const，为了验证可以用 decltype 推导一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B\u0026amp; b; public: A(B\u0026amp; b) : b(b){}; void func() const { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a(b); a.func(); const A a2(b); a2.func(); return 0; } /* non-const B::modify() called B \u0026amp; non-const version non-const B::modify() called B \u0026amp; const version */ 对于按值而非引用储存的成员变量，会有不同的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B b; public: // A(B\u0026amp; b) : b(b){}; void func() const { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b.modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a; a.func(); const A a2; a2.func(); return 0; } /* non-const B::modify() called B \u0026amp; non-const version const B::modify() called B const \u0026amp; const version */ 不清楚编译器在这里做了什么处理，当使用 decltype (b) 时结果均为 B，而使用 decltype ((b)) 时结果显示 const 成员函数中的结果带上了 const 关键字。\n对于使用指针的情况，const 成员函数同样会使其变为指针常量，即不能更换其所指向的地址，但这并不代表此指针指向的是常量，因此可以且会优先匹配非 const 成员函数，最终效果介于引用和非引用之间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; class B { public: void modify() const { std::cout \u0026lt;\u0026lt; \u0026#34;const B::modify() called\\n\u0026#34;; } void modify() { std::cout \u0026lt;\u0026lt; \u0026#34;non-const B::modify() called\\n\u0026#34;; } }; class A { private: B* b; public: A(B* b) : b(b){}; void func() const { b-\u0026gt;modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } void func() { b-\u0026gt;modify(); std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((b))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;non-const version\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } }; int main() { class B b; A a(\u0026amp;b); a.func(); const A a2(\u0026amp;b); a2.func(); return 0; } /* non-const B::modify() called B* \u0026amp; non-const version non-const B::modify() called B* const \u0026amp; const version */ 结论 lambda 闭包重载的 operator () 函数带有 const 关键字，如果按值捕获则只会调用成员变量的带 const 的成员函数。 const 成员函数会使得其中的非引用成员变量被视为 const，从而只能调用其对应的 const 成员函数。 对于指针作为成员变量的情况，在const 成员函数内会变为指针常量，但这并不妨碍其优先调用非 const 的成员变量，因为指针所指向的对象并非 const。 ","date":"2025-03-16T14:49:53+08:00","permalink":"https://localhost:1313/p/lambda%E9%97%AD%E5%8C%85%E4%B8%8Econst%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/","title":"Lambda闭包与const成员函数"},{"content":"类型推导 类型推导主要会发生在以下几种情况：\n模板类型推导 auto 推导 decltype 模板推导 最常见的类型推导是模板中的类型推导，可以根据函数模板的形参的具体形式分为以下三种情况：\n形参为引用或指针，但不是通用引用 形参为通用引用 形参不是任何引用或指针 以上三种情况在进行类型推导时，编译器会按照不同的规则进行，尽管在大多数情况下推导的结果符合直觉而无需套用规则。\n形参为引用或指针，但不是通用引用 在情况下，如果输入的实参是一个引用，则将引用去掉后进行匹配，如果实参并非引用则直接进行匹配。举例说明：\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { int a = 1l; int \u0026amp;b = a; func(a); func(b); } 对应的推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int \u0026amp; param) { } #endif int main() { int a = 1; int \u0026amp; b = a; func(a); func(b); return 0; } 可以看到，对于 int 和 int\u0026amp; 两种类型，最终的推导结果是相同的，也就是说 int\u0026amp; 在进行推导时相当于去掉了\u0026amp;以 int 进行推导，推导结果得到 T 为 int。如果考虑更复杂的情况，即实参是一个指针，则按照规则直接进行匹配，将模板参数 T 推导为 int*，最终得到的形参是 int*\u0026amp;。\n1 2 3 4 5 6 7 8 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { int a = 1; int *c = \u0026amp;a; func(c); } 对应的推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int *\u0026gt;(int *\u0026amp; param) { } #endif int main() { int a = 1L; int * c = \u0026amp;a; func(c); return 0; } 在上面的例子中，去掉引用后的匹配实际上相当于直接使得 T 等于所出入的类型，但当传入参数或者模板形参中任意一者含有 const 时，const 关键字会被保留，区别在于 const 是否属于模板参数 T 的一部分。\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(T\u0026amp; param) {} int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); } 推导结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;const int\u0026gt;(const int \u0026amp; param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); return 0; } 此时由于函数模板的形参中没有 const，const 关键字被推导为 T 的一部分。\n1 2 3 4 5 6 7 8 9 template\u0026lt;typename T\u0026gt; void func(const T\u0026amp; param) {} int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template\u0026lt;typename T\u0026gt; void func(const T \u0026amp; param) { } /* First instantiated from: insights.cpp:7 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(const int \u0026amp; param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); return 0; } 此时 const 关键字不再是 T 的一部分。\n而对于输入的实参为右值的情况，推导规则与左值相同，但只有在推导得出的形参中含有 const 关键字 (模板或实参带有 const 均可) 时才能通过编译。这是因为只有 const 类型的左值引用可以绑定到右值。\n1 2 3 4 5 6 7 8 9 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(const T \u0026amp;param) { } int main() { int a = 1; func(std::move(a)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(const T \u0026amp; param) { } /* First instantiated from: insights.cpp:8 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(const int \u0026amp; param) { } #endif int main() { int a = 1; func(static_cast\u0026lt;const int \u0026amp;\u0026amp;\u0026gt;(std::move(a))); return 0; } 注意 此处并不涉及移动操作，因为触发移动操作的要求是右值引用必须被绑定到对应的T\u0026amp;\u0026amp;形式的形参上。 形参为通用引用 当形参为 T\u0026amp;\u0026amp; 所示的右值引用时，按照如下规则进行推导：\n如果实参为左值，模板参数 T 被推导为左值引用，同时形参发生引用折叠，即 T\u0026amp; \u0026amp;\u0026amp;折叠为 T\u0026amp;，最终形参为左值引用。 如果实参是右值，则直接进行匹配。 1 2 3 4 5 6 7 8 9 10 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(T\u0026amp;\u0026amp; param) { } int main() { int a = 1; func(a); func(std::move(a)); } 上面代码的对应结果为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(T \u0026amp;\u0026amp; param) { } /* First instantiated from: insights.cpp:8 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int \u0026amp;\u0026gt;(int \u0026amp; param) { } #endif /* First instantiated from: insights.cpp:9 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int \u0026amp;\u0026amp; param) { } #endif int main() { int a = 1; func(a); func(std::move(a)); func(1); return 0; } 注意如果模板形参为 const T\u0026amp;\u0026amp;，这并非通用引用，无法触发引用折叠，此模板只能接受右值。\n形参并非任何指针或引用 在这种情况下，由于形参并非引用或指针，实参所带有的引用或 const 声明在函数内不会生效，只会被用来创建函数内的临时变量，因此推导规则为：\n如果实参为引用，则忽略引用 如果忽略引用后带有 const 或 volatile 关键字，则通用忽略他们。 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;utility\u0026gt; template \u0026lt;class T\u0026gt; void func(T param) { } int main() { const int a = 1; const int\u0026amp; b = a; func(a); func(b); func(1); func(std::move(a)); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;utility\u0026gt; template\u0026lt;class T\u0026gt; void func(T param) { } /* First instantiated from: insights.cpp:9 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; void func\u0026lt;int\u0026gt;(int param) { } #endif int main() { const int a = 1; const int \u0026amp; b = a; func(a); func(b); func(1); func(std::move(a)); return 0; } 可以看到无论是输入左值还是右值，最终推导结果是一样的。\nauto 当使用 auto 声明变量时，同样会发生类型推导，而且此时类型推导的规则与上述模板中的类型推导规则基本相同。可以将 auto 本身看作模板参数 T，如果声明为 const auto 则模板函数形参为 const T，以此类推。只有当 auto 声明后出现花括号时，其行为会与模板推导有所不同，auto 会将花括号内的内容推导为初始化列表 std:: initializer_list\u0026lt;T\u0026gt;，而模板函数无法识别花括号输入。\ndecltype 推导规则 decltype 的作用是返回表达式的类型，因此也需要进行类型推导，但其规则比较特殊，按照输入表达式类型的不同，其返回值也不同：\n如果输入不带有括号的标识符或类访问表达式，则直接返回其类型，包括 const 关键字或引用和指针类型。 如果输入的是其他类型为 T 的表达式，则： 如果表达式的值类别为左值，返回 T\u0026amp; 如果表达式的值类别为纯右值，返回 T 如果表达式的值类别为将亡值，返回 T\u0026amp;\u0026amp; note 标识符值为用户自定义的用来表示变量、函数名、类名等自定义模块的名称；变量名、类名、函数名等都属于标识符。 类访问表达式即形如className.member的表达式。 C++中任何表达式都有两个基本属性，即值类别和类型，类型即int, float, double，int*, const double等，值类别指左值、纯右值或将亡值。 举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026#34;cppdemangle.h\u0026#34; int\u0026amp; func1() {} int func2() {} struct X { int* x; const double y = 0; }; int main() { int i = 1; int j = 2; const int\u0026amp; k = i; X stru; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(std::as_const(i))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i + j)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(i += j)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(std::move(i))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(func1())\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(func2())\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype(stru.x)\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((stru.x))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; std::cout \u0026lt;\u0026lt; cppdemangle\u0026lt;decltype((stru.y))\u0026gt;() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } /* 输出： int int const \u0026amp; int int \u0026amp; int \u0026amp;\u0026amp; int \u0026amp; int int * int *\u0026amp; double const \u0026amp; */ 第一种情况直接返回 i 的类型 int，第二中情况属于函数调用，函数返回值为 const int\u0026amp; 为左值，按照规则二结果为 const int \u0026amp;；之后两个加法表达式分别返回右值和左值，按照规则二分别返回 int 和 int \u0026amp;；std:: move () 返回将亡值，因此结果为 int\u0026amp;\u0026amp;，接下来两个函数调用分别返回左值和右值同样按照规则二推导；最后三个中第一个属于类访问表达式，按照规则一直接返回成员变量的类型，第二个在类访问表达式外加上了括号，属于规则二，返回 int* \u0026amp;，同理最后一个返回 const double \u0026amp;。\ndecltype (auto) 一种特殊用法是将 decltype 与 auto 连用，它表示需要进行 auto 推导，但以 decltype 的规则进行：\n1 2 3 4 Widget w; const Widget\u0026amp; cw = w; auto myWidget1 = cw; //按照auto规则myWidget1推导为Widget decltype(auto) myWidget2 = cw; // myWidget2类型为const Widget \u0026amp; 一个常见的用法是在 lambda 表达式或模板函数中自动推导返回值，如果只使用 auto，则返回值的引用类型会在推导过程中被忽略，最终导致返回了一个右值而不是左值引用。使用 decltype (auto) 进行推导则会直接给出返回值的类型，可以配合 std::forward\u0026lt;T\u0026gt; 实现完美转发。\n","date":"2025-03-08T11:26:28+08:00","permalink":"https://localhost:1313/p/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/","title":"类型推导"}]